<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>ATTAMATION - Soil Monitor</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root { --bg:#070617; --card:#0f1220; --accent:#00f1ff; --accent2:#9b4dff; --muted:#9aa3b2; --success:#00ff88; --warning:#ffaa00; --danger:#ff6b6b; --glow:0 8px 30px rgba(155,77,255,0.12); }
* { box-sizing:border-box; }
html,body { height:100%; margin:0; padding:0; font-family:'Inter',Arial,sans-serif; background:radial-gradient(1200px 600px at 10% 10%,rgba(155,77,255,0.06),transparent),linear-gradient(180deg,#060613 0%,#0b0f1a 100%); color:#e6eef8; overflow-x:hidden; }
.wrap { max-width:1200px; margin:0 auto; padding:18px; }
header { display:flex; justify-content:space-between; align-items:center; margin-bottom:18px; flex-wrap:wrap; gap:12px; }
header h1 { font-family:'Orbitron',sans-serif; letter-spacing:2px; color:var(--accent2); margin:0; font-size:28px; }
header .right { text-align:right; color:var(--muted); font-size:14px; }
.tabs { display:flex; gap:8px; margin-bottom:18px; flex-wrap:wrap; }
.tab { padding:10px 20px; border-radius:10px; cursor:pointer; background:rgba(255,255,255,0.02); color:var(--muted); border:1px solid rgba(255,255,255,0.03); font-weight:600; transition:all 0.3s; }
.tab.active { background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#021; }
.tab:hover { background:rgba(255,255,255,0.05); }
.tab.active:hover { background:linear-gradient(90deg,var(--accent),var(--accent2)); }
.tab-content { display:none; }
.tab-content.active { display:block; }
.connection-status { background:rgba(255,255,255,0.02); padding:8px 14px; border-radius:8px; margin-bottom:14px; display:flex; align-items:center; gap:8px; font-size:13px; }
.status-dot { width:10px; height:10px; border-radius:50%; background:var(--danger); }
.status-dot.online { background:var(--success); }
.grid { display:grid; grid-template-columns:1fr 420px; gap:18px; }
.card { background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.007)); border-radius:14px; padding:20px; box-shadow:var(--glow); border:1px solid rgba(255,255,255,0.03); }
.big-stat { display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:300px; }
.big-stat-header { width:100%; display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
.big-stat-title { font-size:16px; color:var(--muted); }
.big-value { font-family:'Orbitron',sans-serif; color:var(--accent); font-size:84px; text-shadow:0 6px 30px rgba(0,241,255,0.08); line-height:1; }
.subtitle { color:var(--muted); margin-top:8px; }
.threshold-info { font-size:12px; color:var(--warning); margin-top:8px; padding:6px 12px; background:rgba(255,170,0,0.1); border-radius:6px; }
.small-row { display:flex; gap:12px; margin-top:18px; justify-content:center; flex-wrap:wrap; }
.stat-mini { background:rgba(255,255,255,0.02); padding:12px; border-radius:10px; min-width:100px; text-align:center; }
.stat-mini h4 { margin:0; font-size:14px; color:var(--muted); }
.stat-mini p { margin:6px 0 0 0; font-weight:700; font-size:15px; }
.control-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; flex-wrap:wrap; gap:12px; }
.control-title { font-weight:700; color:var(--muted); }
.mode-toggle { display:flex; gap:8px; align-items:center; }
.mode-label { font-size:12px; color:var(--muted); }
.mode-select { background:transparent; color:var(--accent); border-radius:8px; padding:6px; border:1px solid rgba(255,255,255,0.03); }
.device-card { background:linear-gradient(180deg,#0b0f1a,#0b0f1a); padding:16px; border-radius:12px; border:1px solid rgba(255,255,255,0.02); margin-bottom:12px; }
.device-row { display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px; }
.device-name { font-weight:600; }
.device-desc { font-size:12px; color:var(--muted); }
.pump-state { color:var(--danger); font-weight:700; font-size:18px; }
.pump-state.on { color:var(--success); }
.controls { margin-top:12px; display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap; }
.control-group { display:flex; flex-direction:column; gap:4px; }
.control-label { font-size:11px; color:var(--muted); }
.control-input { padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--accent); width:70px; font-size:14px; text-align:center; }
.btn { background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#021; padding:8px 14px; border-radius:10px; border:none; font-weight:700; cursor:pointer; font-size:13px; white-space:nowrap; }
.btn.secondary { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.03); }
.btn.danger { background:var(--danger); }
.manual-controls { display:none; margin-left:auto; gap:8px; }
.manual-controls.show { display:flex; }
.info-text { font-size:11px; color:var(--muted); text-align:center; padding-top:8px; line-height:1.6; }
/* History */
.history-container { max-height:400px; overflow-y:auto; }
.history-item { display:flex; justify-content:space-between; align-items:center; padding:12px; background:rgba(255,255,255,0.02); border-radius:8px; margin-bottom:8px; gap:10px; }
.history-icon { font-size:20px; min-width:30px; }
.history-main { flex:1; }
.history-event { font-weight:600; font-size:14px; }
.history-event.on { color:var(--success); }
.history-event.off { color:var(--danger); }
.history-event.auto { color:var(--accent); }
.history-event.manual { color:var(--accent2); }
.history-details { font-size:11px; color:var(--muted); margin-top:2px; }
.history-badge { font-size:10px; padding:2px 6px; border-radius:4px; font-weight:600; }
.history-badge.auto { background:rgba(0,241,255,0.15); color:var(--accent); }
.history-badge.manual { background:rgba(155,77,255,0.15); color:var(--accent2); }
.history-right { text-align:right; }
.history-time { font-size:11px; color:var(--muted); }
.history-soil { font-size:12px; color:var(--accent); font-weight:600; }
/* Charts */
.chart-container { background:rgba(255,255,255,0.02); border-radius:12px; padding:16px; margin-bottom:16px; }
.chart-title { font-size:14px; color:var(--muted); margin-bottom:12px; font-weight:600; }
.chart-wrapper { height:200px; }
.date-controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
.date-select { background:transparent; color:var(--accent); border-radius:8px; padding:6px; border:1px solid rgba(255,255,255,0.03); }
.range-slider { width:100%; }
/* Responsive */
@media(max-width:900px) { .grid{grid-template-columns:1fr;} .big-value{font-size:64px;} header h1{font-size:22px;} }
@media(max-width:600px) { .wrap{padding:12px;} .big-value{font-size:48px;} .big-stat{min-height:auto;padding:16px;} .card{padding:14px;} .small-row{flex-direction:column;width:100%;} .stat-mini{width:100%;} .controls{flex-direction:column;align-items:stretch;} .control-input{width:100%;} .btn{width:100%;} .manual-controls{margin-left:0;width:100%;flex-direction:column;} .tabs{width:100%;} .tab{flex:1;text-align:center;padding:8px 12px;font-size:13px;} }
</style>
</head>
<body>
<div class="wrap">
<header>
  <h1>ATTAMATION</h1>
  <div class="right">
    <div id="clock">--:--:--</div>
    <div id="date">--</div>
  </div>
</header>

<div class="connection-status">
  <div class="status-dot" id="statusDot"></div>
  <span id="statusText">Connecting to MQTT...</span>
</div>

<div class="tabs">
  <div class="tab active" data-tab="dashboard">üìä Dashboard</div>
  <div class="tab" data-tab="history">üìú History</div>
  <div class="tab" data-tab="trends">üìà Trends</div>
</div>

<!-- DASHBOARD TAB -->
<div class="tab-content active" id="tab-dashboard">
<div class="grid">
  <div class="card big-stat">
    <div class="big-stat-header">
      <div class="big-stat-title">SOIL MOISTURE</div>
    </div>
    <div class="big-value" id="soilPercent">--</div>
    <div class="subtitle">Current Level</div>
    <div class="threshold-info" id="thresholdInfo">Pump ON &lt; 35% | OFF ‚â• 40%</div>
    <div class="small-row">
      <div class="stat-mini"><h4>Temp</h4><p id="tempVal">--¬∞C</p></div>
      <div class="stat-mini"><h4>Humidity</h4><p id="humVal">--%</p></div>
      <div class="stat-mini"><h4>Raw</h4><p id="soilRaw">--</p></div>
    </div>
  </div>

  <div class="card">
    <div class="control-header">
      <div class="control-title">DEVICE CONTROL</div>
      <div class="mode-toggle">
        <span class="mode-label">Mode</span>
        <select id="modeSelect" class="mode-select">
          <option value="AUTO">AUTO</option>
          <option value="MANUAL">MANUAL</option>
        </select>
      </div>
    </div>

    <div class="device-card">
      <div class="device-row">
        <div>
          <div class="device-name">üíß Water Pump</div>
          <div class="device-desc">Irrigation System</div>
        </div>
        <div style="text-align:right">
          <div class="pump-state" id="pumpState">OFF</div>
          <div style="font-size:11px;color:var(--muted)">Status</div>
        </div>
      </div>

      <div class="controls">
        <div class="control-group">
          <div class="control-label">Setpoint (%)</div>
          <input id="setpoint" type="number" min="0" max="100" value="40" class="control-input"/>
        </div>
        <div class="control-group">
          <div class="control-label">Hysteresis</div>
          <input id="hysteresis" type="number" min="1" max="20" value="5" class="control-input"/>
        </div>
        <button class="btn" id="setBtn">SET</button>
        <div id="manualControls" class="manual-controls">
          <button class="btn" id="pumpOn">ON</button>
          <button class="btn secondary" id="pumpOff">OFF</button>
        </div>
      </div>
    </div>

    <div class="info-text">
      <div><b>Hysteresis</b> prevents pump flickering</div>
      <div>Pump ON when soil &lt; (setpoint - hysteresis)</div>
      <div>Pump OFF when soil ‚â• setpoint</div>
    </div>
  </div>
</div>
</div>

<!-- HISTORY TAB -->
<div class="tab-content" id="tab-history">
<div class="card">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;flex-wrap:wrap;gap:10px">
    <div class="control-title">üìú SYSTEM HISTORY</div>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <select id="historyFilter" class="mode-select" style="font-size:12px">
        <option value="all">All Events</option>
        <option value="pump">Pump Only</option>
        <option value="mode">Mode Only</option>
        <option value="auto">Auto Trigger</option>
        <option value="manual">Manual Trigger</option>
      </select>
      <select id="historyDate" class="date-select" title="Select date to view history"></select>
      <button class="btn secondary" id="clearHistory">Clear</button>
    </div>
  </div>
  <div class="history-container" id="historyContainer">
    <div style="text-align:center;color:var(--muted);padding:40px">No history yet</div>
  </div>
</div>
</div>

<!-- TRENDS TAB -->
<div class="tab-content" id="tab-trends">
<div class="chart-container">
  <div class="date-controls">
    <div class="chart-title">üå± Soil Moisture Trend</div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
      <label style="font-size:12px;color:var(--muted)">Date:</label>
      <select id="trendDate" class="date-select" title="Select date to view trend"></select>
      <label style="font-size:12px;color:var(--muted)">Window:</label>
      <input id="trendWindow" type="range" min="10" max="1000" value="120" class="range-slider" title="Window size (points)" style="width:180px;">
      <label style="font-size:12px;color:var(--muted)">Shift:</label>
      <input id="trendShift" type="range" min="0" max="0" value="0" class="range-slider" title="Shift" style="width:160px;">
    </div>
  </div>
  <div class="chart-wrapper"><canvas id="soilChart"></canvas></div>
</div>
<div class="chart-container">
  <div class="chart-title">üå°Ô∏è Temperature Trend</div>
  <div class="chart-wrapper"><canvas id="tempChart"></canvas></div>
</div>
<div class="chart-container">
  <div class="chart-title">üíß Humidity Trend</div>
  <div class="chart-wrapper"><canvas id="humChart"></canvas></div>
</div>
<div style="text-align:center;margin-top:12px">
  <button class="btn secondary" id="clearTrends">Clear All Trends</button>
</div>
</div>
</div>

<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
/* ========================
   CONFIG
   ======================== */
const SAMPLE_INTERVAL_SECONDS = 3;      // per request
const RETAIN_DAYS = 14;                // keep last 14 days
const DB_NAME = 'attamation_soil_v1';
const DB_VERSION = 1;

/* ========================
   IndexedDB helpers
   - store 'trends' keyed by date 'YYYY-MM-DD' -> value {labels:[], soil:[], temp:[], hum:[]}
   - store 'history' keyed by date -> array of events
   - store 'meta' for list of dates (optional)
   ======================== */

function openDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      if(!db.objectStoreNames.contains('trends')) db.createObjectStore('trends');
      if(!db.objectStoreNames.contains('history')) db.createObjectStore('history');
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}

async function idbGet(storeName, key){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(storeName,'readonly');
    const st = tx.objectStore(storeName);
    const r = st.get(key);
    r.onsuccess = ()=> res(r.result);
    r.onerror = ()=> rej(r.error);
  });
}

async function idbPut(storeName, key, val){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(storeName,'readwrite');
    const st = tx.objectStore(storeName);
    const r = st.put(val,key);
    r.onsuccess = ()=> res(r.result);
    r.onerror = ()=> rej(r.error);
  });
}

async function idbDelete(storeName, key){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(storeName,'readwrite');
    const st = tx.objectStore(storeName);
    const r = st.delete(key);
    r.onsuccess = ()=> res();
    r.onerror = ()=> rej(r.error);
  });
}

async function idbListKeys(storeName){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(storeName,'readonly');
    const st = tx.objectStore(storeName);
    const req = st.getAllKeys();
    req.onsuccess = ()=> res(req.result);
    req.onerror = ()=> rej(req.error);
  });
}

/* ========================
   Utilities
   ======================== */
function toDateKey(d){ // d = Date or timestamp
  const dt = (d instanceof Date) ? d : new Date(d);
  const y = dt.getFullYear();
  const m = String(dt.getMonth()+1).padStart(2,'0');
  const dd = String(dt.getDate()).padStart(2,'0');
  return `${y}-${m}-${dd}`;
}
function pad(n){ return n<10?'0'+n:n; }

/* ========================
   Data managers (trend & history)
   ======================== */

const trendManager = {
  // append point {ts: timestamp ms, soil, temp, hum}. Save to store for that date
  async addPoint(point){
    // point: {ts, soil, temp, hum}
    const dateKey = toDateKey(point.ts);
    const day = (await idbGet('trends', dateKey)) || {labels:[], soil:[], temp:[], hum:[]};
    // label as HH:MM:SS
    const dt = new Date(point.ts);
    const label = pad(dt.getHours())+':'+pad(dt.getMinutes())+':'+pad(dt.getSeconds());
    day.labels.push(label);
    day.soil.push(typeof point.soil==='number' ? Number(point.soil) : null);
    day.temp.push(typeof point.temp==='number' ? Number(point.temp) : null);
    day.hum.push(typeof point.hum==='number' ? Number(point.hum) : null);
    // basic safety: if day grows extremely big, allow it (IndexedDB), but we will prune older days separately
    await idbPut('trends', dateKey, day);
    await pruneOldDays(); // keep retention
  },

  // get data object for date: {labels, soil, temp, hum}
  async getDataForDate(dateKey){
    return (await idbGet('trends', dateKey)) || {labels:[], soil:[], temp:[], hum:[]};
  },

  // list available dates sorted ascending
  async listDates(){
    const keys = await idbListKeys('trends');
    keys.sort();
    return keys;
  },

  // delete all trend data
  async clearAll(){
    const keys = await idbListKeys('trends');
    await Promise.all(keys.map(k=>idbDelete('trends', k)));
  },

  // estimate points for date (fast)
  async estimatePointsForDate(dateKey){
    const d = await idbGet('trends', dateKey);
    return d ? d.labels.length : 0;
  }
};

const historyManager = {
  async addEvent(event){
    // event: {ts, type, action, trigger, soil}
    const dateKey = toDateKey(event.ts);
    const arr = (await idbGet('history', dateKey)) || [];
    arr.push(event);
    // cap events per day to some reasonable amount (e.g., 10000). We'll keep large enough.
    if(arr.length > 200000) arr.shift();
    await idbPut('history', dateKey, arr);
    await pruneOldDays();
  },

  async getEventsForDate(dateKey){
    return (await idbGet('history', dateKey)) || [];
  },

  async listDates(){
    return (await idbListKeys('history')).sort();
  },

  async clearAll(){
    const keys = await idbListKeys('history');
    await Promise.all(keys.map(k=>idbDelete('history', k)));
  }
};

/* ========================
   Retention: prune days older than RETAIN_DAYS
   ======================== */
async function pruneOldDays(){
  try{
    const now = new Date();
    const cutoff = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (RETAIN_DAYS-1)); // keep today + 13 prev => 14
    const cutoffKey = toDateKey(cutoff);
    // trends
    const trendKeys = await idbListKeys('trends');
    await Promise.all(trendKeys.map(async k=>{
      if(k < cutoffKey){
        // delete older day
        await idbDelete('trends', k);
      }
    }));
    // history
    const histKeys = await idbListKeys('history');
    await Promise.all(histKeys.map(async k=>{
      if(k < cutoffKey){
        await idbDelete('history', k);
      }
    }));
    // done
  }catch(e){ console.warn('Prune error', e); }
}

/* ========================
   UI: date selectors, renderers
   ======================== */

function el(id){ return document.getElementById(id); }

async function populateDateSelectors(){
  // union of trend dates and history dates
  const tdates = await trendManager.listDates();
  const hdates = await historyManager.listDates();
  const set = new Set([...tdates, ...hdates]);
  const dates = Array.from(set).sort();
  const trendSel = el('trendDate');
  const histSel = el('historyDate');
  trendSel.innerHTML = '';
  histSel.innerHTML = '';
  if(dates.length === 0){
    trendSel.innerHTML = '<option value=\"\">(no data)</option>';
    histSel.innerHTML = '<option value=\"\">(no data)</option>';
    return;
  }
  dates.forEach(d=>{
    const o1 = document.createElement('option'); o1.value = d; o1.textContent = d; trendSel.appendChild(o1);
    const o2 = document.createElement('option'); o2.value = d; o2.textContent = d; histSel.appendChild(o2);
  });
  trendSel.value = dates[dates.length-1];
  histSel.value = dates[dates.length-1];
  // update sliders' limits
  await updateTrendSliders();
  // render initial
  renderHistory();
  renderTrends();
}

// Render History for selected date and filter
async function renderHistory(){
  const container = el('historyContainer');
  const dateKey = el('historyDate').value;
  if(!dateKey){ container.innerHTML = '<div style=\"text-align:center;color:var(--muted);padding:40px\">No history yet</div>'; return; }
  let events = await historyManager.getEventsForDate(dateKey);
  const filter = el('historyFilter').value;
  if(filter === 'pump') events = events.filter(e=>e.type==='pump');
  else if(filter === 'mode') events = events.filter(e=>e.type==='mode');
  else if(filter === 'auto') events = events.filter(e=>e.trigger==='auto');
  else if(filter === 'manual') events = events.filter(e=>e.trigger==='manual');
  if(events.length === 0){
    container.innerHTML = '<div style=\"text-align:center;color:var(--muted);padding:40px\">No history on this date</div>';
    return;
  }
  // reverse chronological
  events = events.slice().reverse();
  container.innerHTML = events.map(h=>{
    const icon = (h.type === 'pump') ? (h.action==='ON' ? 'üíß' : 'üö´') : (h.type === 'mode' ? (h.action==='AUTO' ? 'ü§ñ' : 'üñêÔ∏è') : 'üìù');
    const eventClass = (h.action || '').toLowerCase();
    const badgeClass = h.trigger === 'manual' ? 'manual' : 'auto';
    const badgeText = h.trigger === 'manual' ? 'MANUAL' : 'AUTO';
    const soilText = (h.type==='pump' && typeof h.soil==='number') ? ` ‚Ä¢ Soil: ${h.soil}%` : '';
    const time = new Date(h.ts).toLocaleTimeString();
    let text = '';
    if(h.type === 'pump') text = h.action + ' ' + (h.trigger === 'manual' ? '(Manual)' : '(Auto)');
    else if(h.type === 'mode') text = `Mode ‚Üí ${h.action}`;
    else text = h.action || 'Event';
    return `
      <div class="history-item">
        <div class="history-icon">${icon}</div>
        <div class="history-main">
          <div class="history-event ${eventClass}">${text}</div>
          <div class="history-details">
            <span class="history-badge ${badgeClass}">${badgeText}</span>${soilText}
          </div>
        </div>
        <div class="history-right">
          <div class="history-time">${time}</div>
        </div>
      </div>
    `;
  }).join('');
}

// Update the shift/window slider limits based on selected trend date
async function updateTrendSliders(){
  const dateKey = el('trendDate').value;
  if(!dateKey) return;
  const points = await trendManager.estimatePointsForDate(dateKey);
  const wEl = el('trendWindow');
  const sEl = el('trendShift');
  // set reasonable bounds
  const maxWindow = Math.max(10, points);
  wEl.max = Math.max(10, Math.min(20000, maxWindow));
  // default window value: show last N points depending on points (prefer last 120)
  if(!wEl.dataset.userChanged) wEl.value = Math.min(500, Math.max(20, Math.floor(points/10) || 120));
  sEl.max = Math.max(0, points - 10);
  if(sEl.value > sEl.max) sEl.value = sEl.max;
}

// Render trend charts using selected date, window, shift
async function renderTrends(){
  const dateKey = el('trendDate').value;
  if(!dateKey){
    // clear charts
    soilChart.data.labels=[]; soilChart.data.datasets[0].data=[]; soilChart.update();
    tempChart.data.labels=[]; tempChart.data.datasets[0].data=[]; tempChart.update();
    humChart.data.labels=[]; humChart.data.datasets[0].data=[]; humChart.update();
    return;
  }
  const windowPoints = parseInt(el('trendWindow').value,10);
  const shift = parseInt(el('trendShift').value,10) || 0;
  const data = await trendManager.getDataForDate(dateKey);
  const total = data.labels.length;
  if(total === 0){
    soilChart.data.labels=[]; soilChart.data.datasets[0].data=[]; soilChart.update();
    tempChart.data.labels=[]; tempChart.data.datasets[0].data=[]; tempChart.update();
    humChart.data.labels=[]; humChart.data.datasets[0].data=[]; humChart.update();
    return;
  }
  const w = Math.min(windowPoints, total);
  const maxShift = Math.max(0, total - w);
  let sh = Math.min(shift, maxShift);
  const start = Math.max(0, total - w - sh);
  const end = total - sh;
  const labels = data.labels.slice(start, end);
  soilChart.data.labels = labels;
  soilChart.data.datasets[0].data = data.soil.slice(start, end);
  soilChart.update('none');

  tempChart.data.labels = labels;
  tempChart.data.datasets[0].data = data.temp.slice(start, end);
  tempChart.update('none');

  humChart.data.labels = labels;
  humChart.data.datasets[0].data = data.hum.slice(start, end);
  humChart.update('none');

  // update shift slider max to reflect changes
  el('trendShift').max = Math.max(0, total - 10);
}

/* ========================
   Prepare Chart.js charts
   ======================== */
const chartOptions = {
  responsive:true,
  maintainAspectRatio:false,
  scales:{
    x:{display:true,grid:{color:'rgba(255,255,255,0.03)'},ticks:{color:'#9aa3b2',maxTicksLimit:6}},
    y:{display:true,grid:{color:'rgba(255,255,255,0.03)'},ticks:{color:'#9aa3b2'}}
  },
  plugins:{legend:{display:false}},
  elements:{point:{radius:2},line:{tension:0.3}}
};

const soilChart=new Chart(document.getElementById('soilChart'),{
  type:'line',
  data:{labels:[],datasets:[{data:[],borderColor:'#00f1ff',backgroundColor:'rgba(0,241,255,0.1)',fill:true}]},
  options:{...chartOptions,scales:{...chartOptions.scales,y:{...chartOptions.scales.y,min:0,max:100}}}
});

const tempChart=new Chart(document.getElementById('tempChart'),{
  type:'line',
  data:{labels:[],datasets:[{data:[],borderColor:'#ff6b6b',backgroundColor:'rgba(255,107,107,0.1)',fill:true}]},
  options:chartOptions
});

const humChart=new Chart(document.getElementById('humChart'),{
  type:'line',
  data:{labels:[],datasets:[{data:[],borderColor:'#9b4dff',backgroundColor:'rgba(155,77,255,0.1)',fill:true}]},
  options:{...chartOptions,scales:{...chartOptions.scales,y:{...chartOptions.scales.y,min:0,max:100}}}
});

/* ========================
   MQTT integration (kept as your original)
   ======================== */
const mqttHost="a83ccc7ca89145d195e89865c270d0f2.s1.eu.hivemq.cloud";
const mqttUser="Soil_System";
const mqttPass="Soilsystem123";
const clientId="web_"+Math.random().toString(16).substr(2,8);

const client=mqtt.connect(`wss://${mqttHost}:8884/mqtt`,{
  clientId,username:mqttUser,password:mqttPass,reconnectPeriod:3000
});

function updateConnectionStatus(connected){
  document.getElementById('statusDot').classList.toggle('online',connected);
  document.getElementById('statusText').innerText=connected?'Connected to MQTT':'Disconnected - Reconnecting...';
}

function updateManualControls(){
  document.getElementById('manualControls').classList.toggle('show',currentMode==="MANUAL");
}

client.on("connect",()=>{
  console.log("MQTT Connected");
  updateConnectionStatus(true);
  client.subscribe("soil_system/data",(err)=>{ if(err) console.error("Subscribe data error:",err); });
  client.subscribe("soil_system/event",(err)=>{ if(err) console.error("Subscribe event error:",err); });
  setTimeout(()=> client.publish("soil_system/get_data","1"),500);
});

client.on("disconnect",()=>updateConnectionStatus(false));
client.on("error",()=>updateConnectionStatus(false));

client.on("message", async (topic, message)=>{
  const msg = message.toString();
  // console.log("MQTT",topic,msg);
  if(topic === "soil_system/data"){
    try{
      const d = JSON.parse(msg);
      document.getElementById('soilPercent').innerText = (typeof d.soilPercent==='number') ? d.soilPercent+' %' : d.soilPercent;
      document.getElementById('soilRaw').innerText = d.soilRaw === undefined ? '--' : d.soilRaw;
      document.getElementById('tempVal').innerText = (d.temp>-90 && typeof d.temp === 'number') ? d.temp.toFixed(1)+'¬∞C' : '--¬∞C';
      document.getElementById('humVal').innerText = (d.hum>=0 && typeof d.hum === 'number') ? d.hum.toFixed(1)+'%' : '--%';

      const pumpEl = document.getElementById('pumpState');
      const isOn = d.pump === 1;
      pumpEl.innerText = isOn ? 'ON' : 'OFF';
      pumpEl.classList.toggle('on', isOn);

      currentMode = d.mode || currentMode;
      document.getElementById('modeSelect').value = currentMode;
      updateManualControls();

      // setpoint/hysteresis UI
      if(!userEditingSetpoint) document.getElementById('setpoint').value = d.setpoint ?? document.getElementById('setpoint').value;
      if(!userEditingHysteresis) document.getElementById('hysteresis').value = (d.hysteresis ?? document.getElementById('hysteresis').value);

      const low = d.lowThreshold || ( (Number(d.setpoint) || 40) - (Number(d.hysteresis) || 5));
      document.getElementById('thresholdInfo').innerText = `Pump ON < ${low}% | OFF ‚â• ${d.setpoint ?? 40}%`;

      // add trend point into DB (use current timestamp)
      const nowTs = Date.now();
      await trendManager.addPoint({ts: nowTs, soil: (typeof d.soilPercent==='number'? d.soilPercent: null), temp: (typeof d.temp==='number'? d.temp: null), hum: (typeof d.hum==='number'? d.hum: null)});
      // refresh date selectors occasionally
      if(Math.random() < 0.02) populateDateSelectors();
      // if current trendDate is today, append last point to chart (live)
      const selectedTrendDate = el('trendDate').value;
      if(selectedTrendDate === toDateKey(nowTs)){
        // keep sliding window behaviour: show last N points
        const w = parseInt(el('trendWindow').value,10) || 120;
        el('trendShift').value = 0; // auto-slide to latest
        await renderTrends();
      }
    }catch(e){ console.error('Data parse error', e); }
  }

  if(topic === "soil_system/event"){
    try{
      const d = JSON.parse(msg);
      // ensure timestamp: use provided ts or now
      const ts = d.ts ? Number(d.ts) : Date.now();
      const ev = { ts, type: d.type || 'event', action: d.action || '', trigger: d.trigger || 'auto', soil: d.soil };
      await historyManager.addEvent(ev);
      // re-populate selectors sometimes
      if(Math.random() < 0.2) populateDateSelectors();
      // if currently viewing this date, re-render
      if(el('historyDate').value === toDateKey(ts)) renderHistory();
    }catch(e){ console.error('Event parse error', e); }
  }
});

/* ========================
   Input handlers (kept same)
   ======================== */
let userEditingSetpoint = false;
let userEditingHysteresis = false;
let currentMode = "AUTO";

const setpointInput = el('setpoint');
const hysteresisInput = el('hysteresis');

setpointInput.addEventListener('focus',()=>userEditingSetpoint=true);
setpointInput.addEventListener('blur',()=>setTimeout(()=>userEditingSetpoint=false,500));
setpointInput.addEventListener('input',()=>userEditingSetpoint=true);

hysteresisInput.addEventListener('focus',()=>userEditingHysteresis=true);
hysteresisInput.addEventListener('blur',()=>setTimeout(()=>userEditingHysteresis=false,500));
hysteresisInput.addEventListener('input',()=>userEditingHysteresis=true);

el('setBtn').addEventListener('click',()=>{
  let sp = parseInt(setpointInput.value)||40;
  let hy = parseInt(hysteresisInput.value)||5;
  sp = Math.max(0,Math.min(100,sp));
  hy = Math.max(1,Math.min(20,hy));
  userEditingSetpoint=false;
  userEditingHysteresis=false;
  client.publish("soil_system/setpoint",JSON.stringify({setpoint:sp}));
  client.publish("soil_system/hysteresis",JSON.stringify({hysteresis:hy}));
});

el('modeSelect').addEventListener('change',function(){
  currentMode=this.value;
  updateManualControls();
  client.publish("soil_system/setmode",JSON.stringify({mode:this.value}));
});

el('pumpOn').addEventListener('click',()=>{ if(currentMode==="MANUAL") client.publish("soil_system/manualpump",JSON.stringify({state:1})); });
el('pumpOff').addEventListener('click',()=>{ if(currentMode==="MANUAL") client.publish("soil_system/manualpump",JSON.stringify({state:0})); });

/* ========================
   UI events for selectors / sliders
   ======================== */
el('historyFilter').addEventListener('change', renderHistory);
el('historyDate').addEventListener('change', renderHistory);
el('trendDate').addEventListener('change', async ()=>{
  await updateTrendSliders();
  renderTrends();
});
el('trendWindow').addEventListener('input', ()=>{
  el('trendWindow').dataset.userChanged = '1';
  renderTrends();
});
el('trendShift').addEventListener('input', renderTrends);

el('clearHistory').addEventListener('click', async ()=>{
  if(confirm('Clear all history?')){ await historyManager.clearAll(); populateDateSelectors(); renderHistory(); }
});
el('clearTrends').addEventListener('click', async ()=>{
  if(confirm('Clear all trend data?')){ await trendManager.clearAll(); populateDateSelectors(); renderTrends(); }
});

/* ========================
   Initialization
   ======================== */
async function init(){
  try{
    await pruneOldDays();
    await populateDateSelectors();
    // try rendering initial charts/history
    renderHistory();
    renderTrends();
  }catch(e){
    console.error('Init error', e);
  }
  // update clock text
  updateClock();
}

init();

/* ========================
   Expose a manual API for testing (console)
   e.g. call addTestPoint()
   ======================== */
window._att = {
  trendManager,
  historyManager,
  addTestPoint: async (soil,temp,hum,ts=Date.now())=>{
    await trendManager.addPoint({ts,soil,temp,hum});
    await populateDateSelectors();
  },
  addTestEvent: async (type,action,trigger,soil,ts=Date.now())=>{
    await historyManager.addEvent({ts,type,action,trigger,soil});
    await populateDateSelectors();
  },
  pruneOldDays
};
</script>
</body>
</html>
